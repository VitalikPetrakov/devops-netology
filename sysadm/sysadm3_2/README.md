Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"
=======================================
1.	Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.
>cd is a shell builtind  
2.	Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.  
>Grep -c <some_string> <some_file>    

3.	Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?  
>systemd(1)  
4.	Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?  
>Ls 2> /dev/tty2  
5.	Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.  
>cat <test.txt > test2.txt  
6.	Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?  
>root@vagrant:~# bash 1>/dev/tty1  
root@vagrant:~# echo test  
в итоге в TTY1:  
root@vagrant:~# test  

7.	Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?  
>При вводе команды bash 5>&1 мы говорим башу что его stdout переходит под файловый дескриптор №5. И когда в дальнейшем мы передаем в этот дескриптор echo netology срабатывает stdout баша.

8.	Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.  
>root@vagrant:~# cat test1.sh 2>&1 1>/dev/pts/1 | wc –l  
1  
9.	Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?  

>Переменные окружения   
	Printenv  

10.	Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.  
>/proc/<PID>/cmdline  – аргументы командной строки  
/proc/<PID>/exe - ссылка на исполняемый файл, который инициировал запуск процесса  

11.	Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.    
>sse4_2  
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx fxsr_opt rdtscp lm constant_tsc rep_good nopl nonstop_tsc cpuid extd_apicid tsc_known_freq pni ssse3 cx16 sse4_1 sse4_2 hypervisor lahf_lm cmp_legacy cr8_legacy 3dnowprefetch ssbd vmmcall fsgsbase arat  
12.	При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:  
vagrant@netology1:~$ ssh localhost 'tty'  
not a tty  
Почитайте, почему так происходит, и как изменить поведение.   
>Можно насильно пробить соединение по ssh, при этом создается еще один pty  
vagrant@vagrant:~$ ssh -t localhost tty  
vagrant@localhost's password:  
/dev/pts/0  
Connection to localhost closed.  

13.	Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.  
>Получилось перехватить ping с одного pty терминала на другой pty терминал  
root@vagrant:~# lsof | grep ping  
root@vagrant:~# reptyr 2328  
64 bytes from ya.ru (87.250.250.242): icmp_seq=99 ttl=52 time=6.50 ms  
64 bytes from ya.ru (87.250.250.242): icmp_seq=100 ttl=52 time=6.15 ms  
14.	sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.  
>echo string | sudo tee /root/new_file в данном случае мы через пайп передаем строку именно команде, к которой используется повышение привилегий через sudo, что дает нам создать файл в рутовой директории.  


